
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Document</title>
        <style>
        .question {
        border: 5px cornflowerblue solid;
        border-radius: 15px;
        padding: 10px;
        font-size: 24px;
        color: cornflowerblue;
        text-align: center;
    }</style>
        <style>
        .answer {
        width: fit-content;
        margin-left: auto;
        margin-right: auto;
        border: 1px orange solid;
        border-radius: 5px;
        padding: 20px;
        font-size: 20px;
        color: black;
    }</style>
    </head>
    <body>
        
            <p class="question">01.yml&nbsp;Q:&nbsp;Java集合中的各种实现类的应用场景<br></p>
        
            <p class="answer">A:&nbsp;<br>&nbsp;&nbsp;List:<br>&nbsp;&nbsp;&nbsp;&nbsp;ArrayList:&nbsp;适用于读写元素<br>&nbsp;&nbsp;&nbsp;&nbsp;LinkedList:&nbsp;适用于增删元素<br>&nbsp;&nbsp;Queue:<br>&nbsp;&nbsp;&nbsp;&nbsp;ArrayDeque:&nbsp;适用于一般的栈和队列<br>&nbsp;&nbsp;&nbsp;&nbsp;PriorityQueue:&nbsp;适用于调度算法,在需要优先级顺序处理任务时使用<br>&nbsp;&nbsp;Set:<br>&nbsp;&nbsp;&nbsp;&nbsp;HashSet:&nbsp;元素可null,适用于不在意元素排序<br>&nbsp;&nbsp;&nbsp;&nbsp;LinkedHashSet:&nbsp;适用于按插入顺序对元素排序或遍历;<br>&nbsp;&nbsp;&nbsp;&nbsp;TreeSet:&nbsp;元素不可null,任意书顺序排序<br>&nbsp;&nbsp;Map:<br>&nbsp;&nbsp;&nbsp;&nbsp;HashMap:&nbsp;KV可null,适用于无需对KV排序<br>&nbsp;&nbsp;&nbsp;&nbsp;LinkedHashMap:&nbsp;适用于按插入顺序对KV排序或遍历;HashMap<效率<TreeMap<br>&nbsp;&nbsp;&nbsp;&nbsp;TreeMap:&nbsp;适用于任意顺序排序<br>&nbsp;&nbsp;&nbsp;&nbsp;<br></p>
        
            <p class="question">02.yml&nbsp;Q:&nbsp;说说Java集合中的线程安全<br></p>
        
            <p class="answer">A:&nbsp;<br>&nbsp;&nbsp;关系表:&nbsp;><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Queue&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Map<br>&nbsp;&nbsp;&nbsp;&nbsp;原生集合&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vector&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Hashtable&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大部分不安全<br>&nbsp;&nbsp;&nbsp;&nbsp;synchronized&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Map&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用同步锁<br>&nbsp;&nbsp;&nbsp;&nbsp;Concurrent&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LinkedQueue&nbsp;&nbsp;&nbsp;&nbsp;Set&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Map&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;读取操作不加锁,写入时加元素锁<br>&nbsp;&nbsp;&nbsp;&nbsp;CopyOnWrite&nbsp;&nbsp;&nbsp;ArrayList&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ArraySet&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;读取操作不加锁,写入时操作复制的数组<br>&nbsp;&nbsp;HashMap:<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;死循环:多线程同时扩容时形成bucket->1->2->3->3,再遍历就会死循环(链表插入用的头插法)<br>&nbsp;&nbsp;ConcurrentHashMap:<br>&nbsp;&nbsp;&nbsp;&nbsp;JDk7:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;将桶数组分段成多个Segment,每个Segment都是重入锁<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;哈希冲突用数组+链表实现<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;读取不加锁,写入时获取锁(失败多次后挂起),尾插法插入元素<br>&nbsp;&nbsp;&nbsp;&nbsp;JDK8:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;不再将桶分段,每个桶被syn和CAS控制<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;哈希冲突用数组+链表+红黑树实现<br>&nbsp;&nbsp;CopyOnWriteArrayList:<br>&nbsp;&nbsp;&nbsp;&nbsp;原理:&nbsp;读作用于原容器,写作用于加锁的备份容器<br>&nbsp;&nbsp;&nbsp;&nbsp;优劣:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;读写分离,使读即使不加锁也不会有脏读/不可重复读等问题<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;每次写都要备份全部容器,内存抖动<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;每次读的都是原容器的数据,无法保证读的实时性<br>&nbsp;&nbsp;</p>
        
            <p class="question">03.yml&nbsp;Q:&nbsp;Java集合中各实现类的实现细节<br></p>
        
            <p class="answer">A:&nbsp;<br>&nbsp;&nbsp;List:<br>&nbsp;&nbsp;&nbsp;&nbsp;ArrayList:&nbsp;数组实现&nbsp;&&&nbsp;初始[10],扩容时增加[50%]<br>&nbsp;&nbsp;&nbsp;&nbsp;LinkedList:&nbsp;双向链表实现<br>&nbsp;&nbsp;Queue:<br>&nbsp;&nbsp;&nbsp;&nbsp;ArrayDeque:&nbsp;数组实现双端队列<br>&nbsp;&nbsp;&nbsp;&nbsp;PriorityQueue:&nbsp;堆实现优先队列<br>&nbsp;&nbsp;Set:<br>&nbsp;&nbsp;&nbsp;&nbsp;HashSet:&nbsp;委托给HashMap<E,Object>实现<br>&nbsp;&nbsp;&nbsp;&nbsp;LinkedHashSet:&nbsp;委托给LinkedHashMap<E,Object>实现<br>&nbsp;&nbsp;&nbsp;&nbsp;TreeSet:&nbsp;红黑树实现<br>&nbsp;&nbsp;Map:<br>&nbsp;&nbsp;&nbsp;&nbsp;HashMap:&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实现:&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;JDK7时用数组+链表实现<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;JDK8时用数组+链表+红黑树实现<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;扩容:&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;桶初始容量为[16],容量达到[75%]时翻倍<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;链表增长到[8]时转红黑树,红黑树减少到[6]时转链表<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;优先使用String作Key,因为会缓存hash,扩容时无需重复计算<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;平衡树:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;红黑树比B树效率高,因为红黑树的旋转比B树的分类合并快<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;红黑树比B树更容易实现,因为红黑树只需一个颜色标记;链表转B树麻烦<br>&nbsp;&nbsp;&nbsp;&nbsp;LinkedHashMap:&nbsp;用双向链表维护KV的拆入顺序<br>&nbsp;&nbsp;&nbsp;&nbsp;TreeMap:&nbsp;使用红黑树作为排序树<br></p>
        
    </body>
    </html>
