
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0, minimum-scale=1.0, user-scalable=no">
        <title>Document</title>
        <style>
        .question {
        border: 5px cornflowerblue solid;
        border-radius: 15px;
        padding: 10px;
        font-size: 24px;
        color: cornflowerblue;
        text-align: center;
    }</style>
        <style>
        .answer {
        width: fit-content;
        margin-left: auto;
        margin-right: auto;
        border: 1px orange solid;
        border-radius: 5px;
        padding: 20px;
        font-size: 20px;
        color: black;
    }</style>
    </head>
    <body>
        
            <p class="question">01.yml&nbsp;Q:&amp;nbsp;Java集合中的各种实现类的应用场景&lt;br&gt;</p>
        
            <p class="answer">A:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;List:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ArrayList:&amp;nbsp;适用于读写元素&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;LinkedList:&amp;nbsp;适用于增删元素&lt;br&gt;&amp;nbsp;&amp;nbsp;Queue:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ArrayDeque:&amp;nbsp;适用于一般的栈和队列&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;PriorityQueue:&amp;nbsp;适用于调度算法,在需要优先级顺序处理任务时使用&lt;br&gt;&amp;nbsp;&amp;nbsp;Set:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;HashSet:&amp;nbsp;元素可null,适用于不在意元素排序&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;LinkedHashSet:&amp;nbsp;适用于按插入顺序对元素排序或遍历;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;TreeSet:&amp;nbsp;元素不可null,任意书顺序排序&lt;br&gt;&amp;nbsp;&amp;nbsp;Map:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;HashMap:&amp;nbsp;KV可null,适用于无需对KV排序&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;LinkedHashMap:&amp;nbsp;适用于按插入顺序对KV排序或遍历;HashMap&lt;效率&lt;TreeMap&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;TreeMap:&amp;nbsp;适用于任意顺序排序&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br&gt;</p>
        
            <p class="question">02.yml&nbsp;Q:&amp;nbsp;说说Java集合中的线程安全&lt;br&gt;</p>
        
            <p class="answer">A:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;关系表:&amp;nbsp;&gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;List&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Queue&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Set&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Map&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;原生集合&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Vector&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Hashtable&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;大部分不安全&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;synchronized&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;List&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Set&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Map&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;使用同步锁&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Concurrent&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;LinkedQueue&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Set&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Map&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;读取操作不加锁,写入时加元素锁&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;CopyOnWrite&amp;nbsp;&amp;nbsp;&amp;nbsp;ArrayList&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ArraySet&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;读取操作不加锁,写入时操作复制的数组&lt;br&gt;&amp;nbsp;&amp;nbsp;HashMap:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;死循环:多线程同时扩容时形成bucket-&gt;1-&gt;2-&gt;3-&gt;3,再遍历就会死循环(链表插入用的头插法)&lt;br&gt;&amp;nbsp;&amp;nbsp;ConcurrentHashMap:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;JDk7:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;将桶数组分段成多个Segment,每个Segment都是重入锁&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;哈希冲突用数组+链表实现&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;读取不加锁,写入时获取锁(失败多次后挂起),尾插法插入元素&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;JDK8:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;不再将桶分段,每个桶被syn和CAS控制&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;哈希冲突用数组+链表+红黑树实现&lt;br&gt;&amp;nbsp;&amp;nbsp;CopyOnWriteArrayList:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;原理:&amp;nbsp;读作用于原容器,写作用于加锁的备份容器&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;优劣:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;读写分离,使读即使不加锁也不会有脏读/不可重复读等问题&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;每次写都要备份全部容器,内存抖动&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;每次读的都是原容器的数据,无法保证读的实时性&lt;br&gt;&amp;nbsp;&amp;nbsp;</p>
        
            <p class="question">03.yml&nbsp;Q:&amp;nbsp;Java集合中各实现类的实现细节&lt;br&gt;</p>
        
            <p class="answer">A:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;List:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ArrayList:&amp;nbsp;数组实现&amp;nbsp;&amp;&amp;&amp;nbsp;初始[10],扩容时增加[50%]&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;LinkedList:&amp;nbsp;双向链表实现&lt;br&gt;&amp;nbsp;&amp;nbsp;Queue:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ArrayDeque:&amp;nbsp;数组实现双端队列&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;PriorityQueue:&amp;nbsp;堆实现优先队列&lt;br&gt;&amp;nbsp;&amp;nbsp;Set:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;HashSet:&amp;nbsp;委托给HashMap&lt;E,Object&gt;实现&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;LinkedHashSet:&amp;nbsp;委托给LinkedHashMap&lt;E,Object&gt;实现&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;TreeSet:&amp;nbsp;红黑树实现&lt;br&gt;&amp;nbsp;&amp;nbsp;Map:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;HashMap:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;实现:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;JDK7时用数组+链表实现&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;JDK8时用数组+链表+红黑树实现&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;扩容:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;桶初始容量为[16],容量达到[75%]时翻倍&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;链表增长到[8]时转红黑树,红黑树减少到[6]时转链表&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;优先使用String作Key,因为会缓存hash,扩容时无需重复计算&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;平衡树:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;红黑树比B树效率高,因为红黑树的旋转比B树的分类合并快&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;红黑树比B树更容易实现,因为红黑树只需一个颜色标记;链表转B树麻烦&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;LinkedHashMap:&amp;nbsp;用双向链表维护KV的拆入顺序&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;TreeMap:&amp;nbsp;使用红黑树作为排序树&lt;br&gt;</p>
        
    </body>
    </html>
