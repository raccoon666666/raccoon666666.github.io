
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0, minimum-scale=1.0, user-scalable=no">
        <title>Document</title>
        <style>
        .question {
        border: 5px cornflowerblue solid;
        border-radius: 15px;
        padding: 10px;
        font-size: 24px;
        color: cornflowerblue;
        text-align: center;
    }</style>
        <style>
        .answer {
        width: fit-content;
        margin-left: auto;
        margin-right: auto;
        border: 1px orange solid;
        border-radius: 5px;
        padding: 20px;
        font-size: 20px;
        color: black;
    }</style>
    </head>
    <body>
        
            <p class="question">01.yml&nbsp;Q:&nbsp;Redis支持哪些数据类型?如何对其CURD?<br></p>
        
            <p class="answer">A:&nbsp;<br>&nbsp;&nbsp;stirng:&nbsp;set,del,set,get<br>&nbsp;&nbsp;list:&nbsp;lpush,lpop,lset,lindex<br>&nbsp;&nbsp;set:&nbsp;sadd,srem,-,sismember<br>&nbsp;&nbsp;zset:&nbsp;zadd,zrem,zincrby,zrange<br>&nbsp;&nbsp;hash:&nbsp;hset,hdel,-,hget</p>
        
            <p class="question">02.yml&nbsp;Q:&nbsp;Redis为什么能解决高并发的问题?<br></p>
        
            <p class="answer">A:&nbsp;<br>&nbsp;&nbsp;-&nbsp;基于内存,读写速度比磁盘快<br>&nbsp;&nbsp;-&nbsp;基于单线程,减少线程切换的时间耗费,避免了线程同步<br>&nbsp;&nbsp;-&nbsp;基于非阻塞IO多路复用,可处理并发连接<br>&nbsp;&nbsp;-&nbsp;基于Hash结构,另外使用压缩表(压缩短数据)、跳表对数据存储进行优化&nbsp;&nbsp;</p>
        
            <p class="question">03.yml&nbsp;Q:&nbsp;Redis为什么要数据持久化?有哪些方式?各有什么优缺点?<br></p>
        
            <p class="answer">A:&nbsp;<br>&nbsp;&nbsp;持久化的必要性:<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;避免宕机或Redis崩溃<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;Redis重启时快速恢复cache<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;把写缓冲写回DB<br>&nbsp;&nbsp;RDB(Redis&nbsp;Database):<br>&nbsp;&nbsp;&nbsp;&nbsp;步骤:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;开启新进程,防止IO阻塞<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;将内存数据写入备份文件<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;将备份文件替换已有dump.rdb文件<br>&nbsp;&nbsp;&nbsp;&nbsp;优点:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;.rdb体积小,恢复快(适用于大规模数据恢复)<br>&nbsp;&nbsp;&nbsp;&nbsp;缺点:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;需要创建子进程,不适合频繁执行(周期较长,出现故障可能丢失较多数据)<br>&nbsp;&nbsp;AOF(Append&nbsp;Only&nbsp;File):<br>&nbsp;&nbsp;&nbsp;&nbsp;步骤:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;开启新进程,防止IO阻塞<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;加载并压缩appendonly.aof文件到备份文件<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;期间新的写指令同时写入内存缓冲区和appendonly.aof文件<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;备份文件写入完成后,将内存缓冲区写指令写入备份文件<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;将备份文件替换已有appendonly.aof文件(当大小超过阈值,启动内容压缩)<br>&nbsp;&nbsp;&nbsp;&nbsp;优点:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;可实时持久化,丢失的数据少<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;.aof是文本文件,兼容性好,可读性好<br>&nbsp;&nbsp;&nbsp;&nbsp;缺点:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;.aof体积大,恢复慢<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;需要创建子进程,在重写阶段会阻塞<br>&nbsp;&nbsp;RDB-AOF混合:<br>&nbsp;&nbsp;&nbsp;&nbsp;步骤:&nbsp;aof文件中可同时写入rdb数据和aof步骤<br></p>
        
            <p class="question">04.yml&nbsp;Q:&nbsp;Redis的常见问题有哪些?<br></p>
        
            <p class="answer">A:&nbsp;<br>&nbsp;&nbsp;缓存穿透:<br>&nbsp;&nbsp;&nbsp;&nbsp;解释:&nbsp;访问一定会cache失效的数据<br>&nbsp;&nbsp;&nbsp;&nbsp;解决方法:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;cache失效后,使用空值对其缓存<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;在Redis之前加过滤器,过滤掉明显会cache失效的数据<br>&nbsp;&nbsp;缓存击穿:&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;解释:&nbsp;某cache是热点数据,在其失效的瞬间,由于失效大量请求到达DB使其崩溃<br>&nbsp;&nbsp;&nbsp;&nbsp;解决方法:&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;不设置有效期<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;定时重建cache<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;DB层加互斥锁及时重建cache<br>&nbsp;&nbsp;缓存雪崩:&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;解释:&nbsp;Redis崩了/大量cache同时过期,造成大量请求到达DB使其崩溃<br>&nbsp;&nbsp;&nbsp;&nbsp;解决方法:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;有效期加随机数避免同时过期<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;雪崩时,服务端=>把空值/错误信息/预定义信息返回给请求<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;雪崩时,客户端=>不发包直接返回</p>
        
    </body>
    </html>
