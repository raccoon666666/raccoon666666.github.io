
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0, minimum-scale=1.0, user-scalable=no">
        <title>Document</title>
        <style>
        .question {
        border: 5px cornflowerblue solid;
        border-radius: 15px;
        padding: 10px;
        font-size: 24px;
        color: cornflowerblue;
        text-align: center;
    }</style>
        <style>
        .answer {
        width: fit-content;
        margin-left: auto;
        margin-right: auto;
        border: 1px orange solid;
        border-radius: 5px;
        padding: 20px;
        font-size: 20px;
        color: black;
    }</style>
    </head>
    <body>
        
            <p class="question">01.yml&nbsp;Q:&amp;nbsp;Redis支持哪些数据类型?如何对其CURD?&lt;br&gt;</p>
        
            <p class="answer">A:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;stirng:&amp;nbsp;set,del,set,get&lt;br&gt;&amp;nbsp;&amp;nbsp;list:&amp;nbsp;lpush,lpop,lset,lindex&lt;br&gt;&amp;nbsp;&amp;nbsp;set:&amp;nbsp;sadd,srem,-,sismember&lt;br&gt;&amp;nbsp;&amp;nbsp;zset:&amp;nbsp;zadd,zrem,zincrby,zrange&lt;br&gt;&amp;nbsp;&amp;nbsp;hash:&amp;nbsp;hset,hdel,-,hget</p>
        
            <p class="question">02.yml&nbsp;Q:&amp;nbsp;Redis为什么能解决高并发的问题?&lt;br&gt;</p>
        
            <p class="answer">A:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;-&amp;nbsp;基于内存,读写速度比磁盘快&lt;br&gt;&amp;nbsp;&amp;nbsp;-&amp;nbsp;基于单线程,减少线程切换的时间耗费,避免了线程同步&lt;br&gt;&amp;nbsp;&amp;nbsp;-&amp;nbsp;基于非阻塞IO多路复用,可处理并发连接&lt;br&gt;&amp;nbsp;&amp;nbsp;-&amp;nbsp;基于Hash结构,另外使用压缩表(压缩短数据)、跳表对数据存储进行优化&amp;nbsp;&amp;nbsp;</p>
        
            <p class="question">03.yml&nbsp;Q:&amp;nbsp;Redis为什么要数据持久化?有哪些方式?各有什么优缺点?&lt;br&gt;</p>
        
            <p class="answer">A:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;持久化的必要性:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;避免宕机或Redis崩溃&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;Redis重启时快速恢复cache&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;把写缓冲写回DB&lt;br&gt;&amp;nbsp;&amp;nbsp;RDB(Redis&amp;nbsp;Database):&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;步骤:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;开启新进程,防止IO阻塞&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;将内存数据写入备份文件&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;将备份文件替换已有dump.rdb文件&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;优点:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;.rdb体积小,恢复快(适用于大规模数据恢复)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;缺点:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;需要创建子进程,不适合频繁执行(周期较长,出现故障可能丢失较多数据)&lt;br&gt;&amp;nbsp;&amp;nbsp;AOF(Append&amp;nbsp;Only&amp;nbsp;File):&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;步骤:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;开启新进程,防止IO阻塞&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;加载并压缩appendonly.aof文件到备份文件&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;期间新的写指令同时写入内存缓冲区和appendonly.aof文件&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;备份文件写入完成后,将内存缓冲区写指令写入备份文件&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;将备份文件替换已有appendonly.aof文件(当大小超过阈值,启动内容压缩)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;优点:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;可实时持久化,丢失的数据少&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;.aof是文本文件,兼容性好,可读性好&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;缺点:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;.aof体积大,恢复慢&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;需要创建子进程,在重写阶段会阻塞&lt;br&gt;&amp;nbsp;&amp;nbsp;RDB-AOF混合:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;步骤:&amp;nbsp;aof文件中可同时写入rdb数据和aof步骤&lt;br&gt;</p>
        
            <p class="question">04.yml&nbsp;Q:&amp;nbsp;Redis的常见问题有哪些?&lt;br&gt;</p>
        
            <p class="answer">A:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;缓存穿透:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;解释:&amp;nbsp;访问一定会cache失效的数据&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;解决方法:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;cache失效后,使用空值对其缓存&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;在Redis之前加过滤器,过滤掉明显会cache失效的数据&lt;br&gt;&amp;nbsp;&amp;nbsp;缓存击穿:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;解释:&amp;nbsp;某cache是热点数据,在其失效的瞬间,由于失效大量请求到达DB使其崩溃&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;解决方法:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;不设置有效期&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;定时重建cache&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;DB层加互斥锁及时重建cache&lt;br&gt;&amp;nbsp;&amp;nbsp;缓存雪崩:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;解释:&amp;nbsp;Redis崩了/大量cache同时过期,造成大量请求到达DB使其崩溃&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;解决方法:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;有效期加随机数避免同时过期&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;雪崩时,服务端=&gt;把空值/错误信息/预定义信息返回给请求&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;雪崩时,客户端=&gt;不发包直接返回</p>
        
    </body>
    </html>
