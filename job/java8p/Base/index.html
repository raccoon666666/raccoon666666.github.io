
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0, minimum-scale=1.0, user-scalable=no">
        <title>Document</title>
        <style>
        .question {
        border: 5px cornflowerblue solid;
        border-radius: 15px;
        padding: 10px;
        font-size: 24px;
        color: cornflowerblue;
        text-align: center;
    }</style>
        <style>
        .answer {
        width: fit-content;
        margin-left: auto;
        margin-right: auto;
        border: 1px orange solid;
        border-radius: 5px;
        padding: 20px;
        font-size: 20px;
        color: black;
    }</style>
    </head>
    <body>
        
            <p class="question">01.yml&nbsp;Q:&nbsp;为什么Java代码可以实现一次编写、到处运行？<br></p>
        
            <p class="answer">A:&nbsp;<br>&nbsp;&nbsp;编译流程:&nbsp;.java源代码&nbsp;=&gt;&nbsp;.class字节码&nbsp;=&gt;&nbsp;被JVM翻译成机器码执行<br>&nbsp;&nbsp;JVM:&nbsp;不同的平台对于JVM有不同的实现,而.class字节码是相同的</p>
        
            <p class="question">02.yml&nbsp;Q:&nbsp;说一说你对Java访问权限的了解<br></p>
        
            <p class="answer">A:&nbsp;<br>&nbsp;&nbsp;成员的访问范围:&nbsp;类内部&nbsp;&lt;&nbsp;同包类&nbsp;&lt;&nbsp;子类&nbsp;&lt;&nbsp;任何类<br>&nbsp;&nbsp;权限:<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;类&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;成员<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;public&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;任何类&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;任何类<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;protected&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;子类<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;default&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同包类&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同包类<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;private&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本类</p>
        
            <p class="question">03.yml&nbsp;Q:&nbsp;Java的数据类型<br></p>
        
            <p class="answer">A:&nbsp;<br>&nbsp;&nbsp;-&nbsp;byte(1),short(2),int(4),long(8),float(4),double(8)]<br>&nbsp;&nbsp;-&nbsp;char(2)<br>&nbsp;&nbsp;-&nbsp;boolean(?)</p>
        
            <p class="question">04.yml&nbsp;Q:&nbsp;全局变量与局部变量的区别<br></p>
        
            <p class="answer">A:&nbsp;<br>&nbsp;&nbsp;-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;类型&nbsp;&nbsp;&nbsp;&nbsp;位置&nbsp;&nbsp;&nbsp;&nbsp;初始值&nbsp;&nbsp;&nbsp;生命周期&nbsp;&nbsp;&nbsp;识别<br>&nbsp;&nbsp;-&nbsp;全局变量&nbsp;&nbsp;&nbsp;static&nbsp;&nbsp;方法区&nbsp;&nbsp;&nbsp;0x00&nbsp;&nbsp;&nbsp;&nbsp;同Klass&nbsp;&nbsp;&nbsp;绝对地址<br>&nbsp;&nbsp;-&nbsp;局部变量&nbsp;&nbsp;&nbsp;方法内&nbsp;&nbsp;&nbsp;VM栈&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同栈帧&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;相对地址<br>&nbsp;&nbsp;-&nbsp;成员变量&nbsp;&nbsp;&nbsp;&nbsp;成员&nbsp;&nbsp;&nbsp;&nbsp;堆区&nbsp;&nbsp;&nbsp;&nbsp;0x00&nbsp;&nbsp;&nbsp;&nbsp;同对象&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;绝对地址</p>
        
            <p class="question">05.yml&nbsp;Q:&nbsp;包装类的意义是什么<br></p>
        
            <p class="answer">A:&nbsp;<br>&nbsp;&nbsp;-&nbsp;上溯为Object,作形参可接收null,作实参可传入Object<br>&nbsp;&nbsp;-&nbsp;泛型,使变量能放入集合<br>&nbsp;&nbsp;-&nbsp;储存在堆中,可在运行时动态创建<br>&nbsp;&nbsp;-&nbsp;设计为不可变类,保证线程安全,保证常量缓存<br>&nbsp;&nbsp;-&nbsp;能使用注解进行参数校验</p>
        
            <p class="question">06.yml&nbsp;Q:&nbsp;介绍一些Object中的方法<br></p>
        
            <p class="answer">A:&nbsp;<br>&nbsp;&nbsp;equals:&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;返回判断一个对象是否与自己相等<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;要求:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;正确判断异类和null<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;必须满足自反、对称、传递、一致性<br>&nbsp;&nbsp;hashCode:<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;返回this的哈希值<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;要求:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;相等obj的哈希相等<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;不等的obj的哈希必须不等<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;尽量减小哈希碰撞<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;必须重写,哈希默认是obj的地址值,否则只有obj==obj时哈希才相等<br>&nbsp;&nbsp;toString:<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;返回对象的字符串值<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;在sout和+时自动调用<br>&nbsp;&nbsp;clone:<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;返回一个深拷贝对象<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;默认为protected,因为必须重写才能使用<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;否则由于任何类都继承Object而使用默认clone()返回了预期之外的对象<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;子类将其重写为public,并实现Cloneable接口,表示自己实现了clone()<br>&nbsp;&nbsp;wait.notify.notifyAll:&nbsp;多线程相关<br>&nbsp;&nbsp;finalize:<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;被GC前执行的动作<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;由于通过该方法this可能重新被引用而不被GC,下次被GC时又被引用而死循环,所以finalize只被调用一次</p>
        
            <p class="question">07.yml&nbsp;Q:&nbsp;为什么String是不可变的?<br></p>
        
            <p class="answer">A:&nbsp;<br>&nbsp;&nbsp;原因:&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;String内部是private&nbsp;final&nbsp;byte[],没有提供修改其值的方法(反射可以)<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;String是fianl类,所以杜绝了继承为可变类的可能性<br>&nbsp;&nbsp;常量池:&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;字符串被大量使用,有必要复用相同的字符串<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;如果字符串对象可变,那么指向该对象的引用都会受到影响<br>&nbsp;&nbsp;常量哈希:<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;map的key一般使用不可变类型、而String是广泛使用的key<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;字符串内部不可变,所以实例化后可立即计算出hash然后缓存<br>&nbsp;&nbsp;数据安全:<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;字符串中保存了敏感信息<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;如果可变,则在运行时会被修改字符<br>&nbsp;&nbsp;线程安全:<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;多个线程共享堆对象<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;如果可变,则一个线程对字符的修改会影响其他线程</p>
        
            <p class="question">08.yml&nbsp;Q:&nbsp;说一说你对字符串拼接的理解<br></p>
        
            <p class="answer">A:&nbsp;<br>&nbsp;&nbsp;三种拼接方法:<br>&nbsp;&nbsp;&nbsp;&nbsp;加号操作符:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;对于&quot;a&quot;+&quot;b&quot;:&nbsp;直接被编译器优化,效率高<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;对于&quot;a&quot;+var:&nbsp;自动实例化StringBuilder拼接,循环时效率低<br>&nbsp;&nbsp;&nbsp;&nbsp;变长字符串:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;类似于vector一类容器,频繁扩容使效率降低<br>&nbsp;&nbsp;&nbsp;&nbsp;concat:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;新建一个bytes[],然后复制两字符串,然后实例化String<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;拼接两字符串效率高,拼接大量字符串效率低<br>&nbsp;&nbsp;拼接方法的选择:<br>&nbsp;&nbsp;&nbsp;&nbsp;全是字面量:&nbsp;加号操作符<br>&nbsp;&nbsp;&nbsp;&nbsp;大量拼接:&nbsp;变长字符串<br>&nbsp;&nbsp;&nbsp;&nbsp;两个拼接:&nbsp;concat<br><br><br></p>
        
            <p class="question">09.yml&nbsp;Q:&nbsp;说说你对static关键字的理解<br></p>
        
            <p class="answer">A:&nbsp;<br>&nbsp;&nbsp;本质:&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;使成员不再依赖于实例对象,而抽象为对象的共性,即依赖于类<br>&nbsp;&nbsp;修饰成员:<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;用于修饰类的成员(字段,方法,初始块,内部类)<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;静态成员无法使用this,因为系统未为其传入<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;静态成员在类被加载时,一同被加载进堆的方法区,直接通过类名调用<br>&nbsp;&nbsp;修饰类:<br>&nbsp;&nbsp;&nbsp;&nbsp;静态内部类:&nbsp;内部类不再依赖于外部类的对象,可直接使用<br>&nbsp;&nbsp;&nbsp;&nbsp;内部类:&nbsp;无法声明static成员,因为与内部类依赖于外部类矛盾<br>&nbsp;&nbsp;&nbsp;&nbsp;外部类:&nbsp;外层是包,没有实例化的概念,所以外部类不依赖包,所以没必要用static修饰<br>&nbsp;&nbsp;&nbsp;&nbsp;局部类:&nbsp;外层是方法,也没有实例化的概念</p>
        
            <p class="question">10.yml&nbsp;Q:&nbsp;说说你对final关键字的理解<br></p>
        
            <p class="answer">A:&nbsp;<br>&nbsp;&nbsp;本质:&nbsp;使被修饰的目标&quot;不可变&quot;<br>&nbsp;&nbsp;修饰属性:&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;需在构造函数或初始块中初始化,final局部变量的首次赋值视为初始化<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;变量的值不可变&amp;引用的指向不可变<br>&nbsp;&nbsp;修饰方法:&nbsp;方法不可被子类重写<br>&nbsp;&nbsp;修饰类:&nbsp;类不可被继承<br></p>
        
            <p class="question">11.yml&nbsp;Q:&nbsp;Lambda与匿名内部类有什么区别?<br></p>
        
            <p class="answer">A:&nbsp;<br>&nbsp;&nbsp;-&nbsp;Lambda的语法简洁,隐式重写<br>&nbsp;&nbsp;-&nbsp;匿名内部类被编译成单独class文件,Lambda不会<br>&nbsp;&nbsp;-&nbsp;Lambda只适用于单方法接口,&nbsp;匿名内部类使用范围广:普通类,接口,抽象类</p>
        
            <p class="question">12.yml&nbsp;Q:&nbsp;Object的hashCode是怎么生成的?<br></p>
        
            <p class="answer">A:<br>&nbsp;&nbsp;总概:<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;使用System.identityHashCode(obj)无视重写<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;可通过JVM运行参数修改hashCode的生成策略<br>&nbsp;&nbsp;要求:<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;对象相同&nbsp;=&gt;&nbsp;hashCode相同<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;对象不同&nbsp;=&gt;&nbsp;hashCode未知(尽量不同)<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;hashCode不同&nbsp;=&gt;&nbsp;对象未知<br>&nbsp;&nbsp;生成策略:<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;对象的内存地址(默认)<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;一种随机数<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;固定值<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;自增</p>
        
            <p class="question">13.yml&nbsp;Q:&nbsp;说说你对泛型的理解<br></p>
        
            <p class="answer">A:&nbsp;<br>&nbsp;&nbsp;早期集合:<br>&nbsp;&nbsp;&nbsp;&nbsp;原理:&nbsp;保存Object;存入时上溯为Object;取出时丢失了实际类型,只能下溯<br>&nbsp;&nbsp;&nbsp;&nbsp;问题:&nbsp;取出时要判断继承关系再下溯(冗杂而不完备的判断逻辑)<br>&nbsp;&nbsp;擦除:<br>&nbsp;&nbsp;&nbsp;&nbsp;本质:&nbsp;编译后去除所有泛型信息,底层还是Object(或泛型上界),但是编译期有严格类型检查<br>&nbsp;&nbsp;&nbsp;&nbsp;问题:&nbsp;[new&nbsp;T,instance&nbsp;T]<br>&nbsp;&nbsp;&nbsp;&nbsp;桥方法:&nbsp;由于泛型类只有一个类元,主观上的重写实际无效,需要桥接转发<br>&nbsp;&nbsp;数组协变:<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;一切数组都是Object的子类,但元素满足继承的数组可以兼容<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;当Number[]&nbsp;obj&nbsp;=&nbsp;new&nbsp;Integer[10];对于obj[0]=0.1;编译不会出错,但运行会出错<br>&nbsp;&nbsp;泛型协变:<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;认识到数组协变的危害,泛型设计成不能协变<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;为了尽量避免数组协变,泛型类不能声明为数组<br>&nbsp;&nbsp;通配符:<br>&nbsp;&nbsp;&nbsp;&nbsp;本质:&nbsp;范围小的能赋值给范围大的<br>&nbsp;&nbsp;&nbsp;&nbsp;生产者PE:&nbsp;'?&nbsp;extends&nbsp;Number,Get为Number,禁止Set'<br>&nbsp;&nbsp;&nbsp;&nbsp;消费者CS:&nbsp;'?&nbsp;super&nbsp;Integer',Get为Object,Set为Integer</p>
        
            <p class="question">14.yml&nbsp;Q:&nbsp;Class&lt;?&gt;和Class&lt;Object&gt;有什么区别<br></p>
        
            <p class="answer">A:&nbsp;<br>&nbsp;&nbsp;-&nbsp;Class&lt;?&gt;保留了泛型变量信息,可通过反射获取<br>&nbsp;&nbsp;-&nbsp;使用Class&lt;?&nbsp;extends&nbsp;XXX&gt;可进一步限制范围,比Object灵活<br>&nbsp;&nbsp;-&nbsp;<br></p>
        
    </body>
    </html>
