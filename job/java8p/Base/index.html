
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0, minimum-scale=1.0, user-scalable=no">
        <title>Document</title>
        <style>
        .question {
        border: 5px cornflowerblue solid;
        border-radius: 15px;
        padding: 10px;
        font-size: 24px;
        color: cornflowerblue;
        text-align: center;
    }</style>
        <style>
        .answer {
        width: fit-content;
        margin-left: auto;
        margin-right: auto;
        border: 1px orange solid;
        border-radius: 5px;
        padding: 20px;
        font-size: 20px;
        color: black;
    }</style>
    </head>
    <body>
        
            <p class="question">01.yml&nbsp;Q:&amp;nbsp;面向对象三大特性&lt;br&gt;</p>
        
            <p class="answer">A:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;抽象:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;对具体问题概括,抽象出公用性质,忽略无关性质&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;数据抽象(属性/状态)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;行为抽象(行为/功能)&lt;br&gt;&amp;nbsp;&amp;nbsp;封装:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;将数据抽象和行为抽象形成一个有机的整体&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;对外部世界隐藏内部的实现细节(某些状态值,某些行为的实现)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;该藏的藏该露的露:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;规范对数据的访问(为数据结构指定访问规范)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;内置数据检查操作数据更安全&lt;br&gt;&amp;nbsp;&amp;nbsp;继承:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;在现有类的基础上构建新的类,形成父类子类&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;子类重用父类的方数据/行为抽象,并可进行扩展&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;有利于代码的重用,简化了子类的设计&lt;br&gt;&amp;nbsp;&amp;nbsp;多态:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;广义多态:&amp;nbsp;强制多态,重载多态,泛型多态,包含多态&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;包含多态:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;子类对父类方法重写,通过上溯将子类赋值给父类&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;一切调用用父对象的形式,在运行时,对同一消息作出不同响应的能力&lt;br&gt;&amp;nbsp;&amp;nbsp;总结:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;这三大特性实现了代码的高内聚、低耦合&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;调了程序的可维护性和可扩展性</p>
        
            <p class="question">02.yml&nbsp;Q:&amp;nbsp;为什么Java代码可以实现一次编写、到处运行？&lt;br&gt;</p>
        
            <p class="answer">A:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;编译流程:&amp;nbsp;.java源代码&amp;nbsp;=&gt;&amp;nbsp;.class字节码&amp;nbsp;=&gt;&amp;nbsp;被JVM翻译成机器码执行&lt;br&gt;&amp;nbsp;&amp;nbsp;JVM:&amp;nbsp;不同的平台对于JVM有不同的实现,而.class字节码是相同的</p>
        
            <p class="question">03.yml&nbsp;Q:&amp;nbsp;说一说你对Java访问权限的了解&lt;br&gt;</p>
        
            <p class="answer">A:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;成员的访问范围:&amp;nbsp;类内部&amp;nbsp;&lt;&amp;nbsp;同包类&amp;nbsp;&lt;&amp;nbsp;子类&amp;nbsp;&lt;&amp;nbsp;任何类&lt;br&gt;&amp;nbsp;&amp;nbsp;public:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;class:&amp;nbsp;任何类&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;member:&amp;nbsp;任何类&lt;br&gt;&amp;nbsp;&amp;nbsp;protected:&amp;nbsp;子类&lt;br&gt;&amp;nbsp;&amp;nbsp;default:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;class:&amp;nbsp;同包类&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;member:&amp;nbsp;同包类&lt;br&gt;&amp;nbsp;&amp;nbsp;private:&amp;nbsp;类内部</p>
        
            <p class="question">04.yml&nbsp;Q:&amp;nbsp;Java的数据类型&lt;br&gt;</p>
        
            <p class="answer">A:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;-&amp;nbsp;包括3大类8小类&lt;br&gt;&amp;nbsp;&amp;nbsp;-&amp;nbsp;Number:&amp;nbsp;[byte(1),short(2),int(4),long(8),float(4),double(8)]&lt;br&gt;&amp;nbsp;&amp;nbsp;-&amp;nbsp;char(2)&lt;br&gt;&amp;nbsp;&amp;nbsp;-&amp;nbsp;boolean(?)</p>
        
            <p class="question">05.yml&nbsp;Q:&amp;nbsp;全局变量与局部变量的区别&lt;br&gt;</p>
        
            <p class="answer">A:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;成员变量:&amp;nbsp;类的属性&lt;br&gt;&amp;nbsp;&amp;nbsp;全局变量:&amp;nbsp;static变量&lt;br&gt;&amp;nbsp;&amp;nbsp;局部变量:&amp;nbsp;方法内变量&lt;br&gt;&amp;nbsp;&amp;nbsp;位置:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;成员变量位于堆,初始为全0&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;全局变量位于堆的方法区&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;局部变量位于栈,没有初始值&lt;br&gt;&amp;nbsp;&amp;nbsp;生命周期:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;成员变量随对象的实例化而创建,随对象回收也回收&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;全局变量随类的加载而创建&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;局部变量随函数调用结束,栈帧被销毁而回收&lt;br&gt;&amp;nbsp;&amp;nbsp;识别:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;根据绝对地址访问全局变量&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;根据栈的相对地址访问局部变量</p>
        
            <p class="question">06.yml&nbsp;Q:&amp;nbsp;包装类的意义是什么&lt;br&gt;</p>
        
            <p class="answer">A:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;-&amp;nbsp;泛型,使变量能放入集合&lt;br&gt;&amp;nbsp;&amp;nbsp;-&amp;nbsp;上溯为Object,适用于接收Object的方法&lt;br&gt;&amp;nbsp;&amp;nbsp;-&amp;nbsp;储存在堆中,可在运行时动态创建</p>
        
            <p class="question">07.yml&nbsp;Q:&amp;nbsp;什么是面向对象,与面向过程的差别&lt;br&gt;</p>
        
            <p class="answer">A:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;面向对象:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;将系统的需求抽象成各种&lt;对象&gt;之间的交互&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;将这些对象的本质特点抽象为类,作为系统的基本单位&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;使得系统能直接映射到物理世界&lt;br&gt;&amp;nbsp;&amp;nbsp;面向过程:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;将系统的需求抽象成各种&lt;流程&gt;之间的调用,对数据得加工&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;将这些流程自顶向下/逐步求精地划分为函数,作为系统的基本单位&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;不符合人的思维习惯,可扩展性不如面向对象</p>
        
            <p class="question">08.yml&nbsp;Q:&amp;nbsp;为什么java要做成单继承,为什么接口可以多继承&lt;br&gt;</p>
        
            <p class="answer">A:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;类的(父类)有相同签名的方法时:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;继承不会出错&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;调用和重写时会产生二义性&lt;br&gt;&amp;nbsp;&amp;nbsp;类的(父类,接口)有相同签名的方法时:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;继承不会出错&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;调用和重写不会出错&lt;br&gt;&amp;nbsp;&amp;nbsp;类的(接口)中有相同签名的方法时:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;必须重写&lt;br&gt;&amp;nbsp;&amp;nbsp;接口的(父接口)中有相同签名的方法时:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;同名方法全抽象时无需重写&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;存在default必须重写&lt;br&gt;&amp;nbsp;&amp;nbsp;总结:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;一切重名都可通过重写解决&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;重写时使用I.super.fun来综合调用重名的方法</p>
        
            <p class="question">09.yml&nbsp;Q:&amp;nbsp;重写和重载的区别&lt;br&gt;</p>
        
            <p class="answer">A:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;重载:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;发生在同一个类中&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;(方法名相同,参数的个数或类型不同)构成重载&lt;br&gt;&amp;nbsp;&amp;nbsp;重载的限制条件:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;返回值类型的不同不能构成重载,会重定义错误&lt;br&gt;&amp;nbsp;&amp;nbsp;重写:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;发生在子类中&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;(方法名相同,参数的个数和类型相同)构成重写&lt;br&gt;&amp;nbsp;&amp;nbsp;重写的桥方法:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;编译器的方法签名是(方法名,参数列表),JVM的方法签名是(返回类型,方法名,参数列表)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;比如public&amp;nbsp;Number&amp;nbsp;show(){}的重写public&amp;nbsp;Integer&amp;nbsp;show(){}在JVM看来不是重写&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;所以要自动生成public&amp;nbsp;Number&amp;nbsp;show(){return&amp;nbsp;show();}重载型&lt;br&gt;&amp;nbsp;&amp;nbsp;重写的限制条件:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;访问权限要更大,否则不能正常访问&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;返回类型更小,否则不能赋值给Number&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;抛出异常要更少更小,否则不能捕获&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;对于多继承,对于每个同名方法都要满足上述条件&lt;br&gt;</p>
        
            <p class="question">10.yml&nbsp;Q:&amp;nbsp;为什么不能重写构造方法&lt;br&gt;</p>
        
            <p class="answer">A:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;-&amp;nbsp;构造方法没有返回值名字与类名相同,所以子类无法重写只会视为一个普通方法&lt;br&gt;&amp;nbsp;&amp;nbsp;-&amp;nbsp;构造方法无法被继承,所以没有重写一说&lt;br&gt;&amp;nbsp;&amp;nbsp;-&amp;nbsp;重写时为了多态,通过调用已存在对象的方法来实现多态,构造方法产生对象,所以重写它没有意义&lt;br&gt;</p>
        
            <p class="question">11.yml&nbsp;Q:&amp;nbsp;介绍一些Object中的方法&lt;br&gt;</p>
        
            <p class="answer">A:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;equals:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;返回判断一个对象是否与自己相等&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;要求:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;正确判断异类和null&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;必须满足自反、对称、传递、一致性&lt;br&gt;&amp;nbsp;&amp;nbsp;hashCode:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;返回this的哈希值&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;要求:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;相等obj的哈希相等&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;不等的obj的哈希必须不等&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;尽量减小哈希碰撞&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;必须重写,哈希默认是obj的地址值,否则只有obj==obj时哈希才相等&lt;br&gt;&amp;nbsp;&amp;nbsp;toString:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;返回对象的字符串值&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;在sout和+时自动调用&lt;br&gt;&amp;nbsp;&amp;nbsp;clone:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;返回一个深拷贝对象&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;默认为protected,因为必须重写才能使用&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;否则由于任何类都继承Object而使用默认clone()返回了预期之外的对象&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;子类将其重写为public,并实现Cloneable接口,表示自己实现了clone()&lt;br&gt;&amp;nbsp;&amp;nbsp;wait.notify.notifyAll:&amp;nbsp;多线程相关&lt;br&gt;&amp;nbsp;&amp;nbsp;finalize:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;被GC前执行的动作&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;由于通过该方法this可能重新被引用而不被GC,下次被GC时又被引用而死循环,所以finalize只被调用一次</p>
        
            <p class="question">12.yml&nbsp;Q:&amp;nbsp;为什么String是不可变的?&lt;br&gt;</p>
        
            <p class="answer">A:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;原因:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;String内部是private&amp;nbsp;final&amp;nbsp;byte[],没有提供修改其值的方法(反射可以)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;String是fianl类,所以杜绝了继承为可变类的可能性&lt;br&gt;&amp;nbsp;&amp;nbsp;常量池:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;字符串被大量使用,有必要复用相同的字符串&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;如果字符串对象可变,那么指向该对象的引用都会受到影响&lt;br&gt;&amp;nbsp;&amp;nbsp;常量哈希:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;map的key一般使用不可变类型、而String是广泛使用的key&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;字符串内部不可变,所以实例化后可立即计算出hash然后缓存&lt;br&gt;&amp;nbsp;&amp;nbsp;数据安全:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;字符串中保存了敏感信息&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;如果可变,则在运行时会被修改字符&lt;br&gt;&amp;nbsp;&amp;nbsp;线程安全:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;多个线程共享堆对象&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;如果可变,则一个线程对字符的修改会影响其他线程</p>
        
            <p class="question">13.yml&nbsp;Q:&amp;nbsp;说一说你对字符串拼接的理解&lt;br&gt;</p>
        
            <p class="answer">A:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;三种拼接方法:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;加号操作符:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;对于&quot;a&quot;+&quot;b&quot;:&amp;nbsp;直接被编译器优化,效率高&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;对于&quot;a&quot;+var:&amp;nbsp;自动实例化StringBuilder拼接,循环时效率低&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;变长字符串:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;类似于vector一类容器,频繁扩容使效率降低&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;concat:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;新建一个bytes[],然后复制两字符串,然后实例化String&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;拼接两字符串效率高,拼接大量字符串效率低&lt;br&gt;&amp;nbsp;&amp;nbsp;拼接方法的选择:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;全是字面量:&amp;nbsp;加号操作符&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;大量拼接:&amp;nbsp;变长字符串&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;两个拼接:&amp;nbsp;concat&lt;br&gt;&lt;br&gt;&lt;br&gt;</p>
        
            <p class="question">14.yml&nbsp;Q:&amp;nbsp;接口和抽象类有什么异同？&lt;br&gt;</p>
        
            <p class="answer">A:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;成员:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;属性:&amp;nbsp;接口可以有属性,但必须初始化(否则无法初始化)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;构造方法:&amp;nbsp;接口没有构造方法,抽象类有但仅供子类用&lt;br&gt;&amp;nbsp;&amp;nbsp;修饰符:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;接口没有private属性&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;都可以有private方法,但必须马上实现(否则无法实现)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;protected:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;接口没有protected属性&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;接口没有protected方法&lt;br&gt;&amp;nbsp;&amp;nbsp;初始化块:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;接口中不允许初始化块和静态初始化块&lt;br&gt;&amp;nbsp;&amp;nbsp;功能:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;接口是规范,为多模块耦合提供标准,为多系统通信提供标准(上溯为接口类型)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;抽象类是模板,供不同的策略作出不同的实现(char)&lt;br&gt;&amp;nbsp;&amp;nbsp;相同点:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;都不能实例化,&amp;nbsp;需要显式或隐式继承&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;子类都必须实现其定义的抽象方法</p>
        
            <p class="question">15.yml&nbsp;Q:&amp;nbsp;OOP和IOP有哪些区别?&lt;br&gt;</p>
        
            <p class="answer">A:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;抽象级别:&amp;nbsp;OOP强调封装继承多态,IOP强调抽象和多态&lt;br&gt;&amp;nbsp;&amp;nbsp;用途:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;OOP通过对象间协作完成系统任务&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;IOP通过多态实现多策略,在类基础上抽象出公用方法作为接口,调用方只关心这些接口里的方法&lt;br&gt;&amp;nbsp;&amp;nbsp;耦合:&amp;nbsp;IOP耦合度比OOP低&lt;br&gt;&amp;nbsp;&amp;nbsp;测试:&amp;nbsp;IOP可测试性比OOP高</p>
        
            <p class="question">16.yml&nbsp;Q:&amp;nbsp;说说你对static关键字的理解&lt;br&gt;</p>
        
            <p class="answer">A:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;本质:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;使成员不再依赖于实例对象,而抽象为对象的共性,即依赖于类&lt;br&gt;&amp;nbsp;&amp;nbsp;修饰成员:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;用于修饰类的成员(字段,方法,初始块,内部类)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;静态成员无法使用this,因为系统未为其传入&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;静态成员在类被加载时,一同被加载进堆的方法区,直接通过类名调用&lt;br&gt;&amp;nbsp;&amp;nbsp;修饰类:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;静态内部类:&amp;nbsp;内部类不再依赖于外部类的对象,可直接使用&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;内部类:&amp;nbsp;无法声明static成员,因为与内部类依赖于外部类矛盾&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;外部类:&amp;nbsp;外层是包,没有实例化的概念,所以外部类不依赖包,所以没必要用static修饰&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;局部类:&amp;nbsp;外层是方法,也没有实例化的概念</p>
        
            <p class="question">17.yml&nbsp;Q:&amp;nbsp;说说你对final关键字的理解&lt;br&gt;</p>
        
            <p class="answer">A:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;本质:&amp;nbsp;使被修饰的目标&quot;不可变&quot;&lt;br&gt;&amp;nbsp;&amp;nbsp;修饰属性:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;需在构造函数或初始块中初始化,final局部变量的首次赋值视为初始化&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;变量的值不可变&amp;引用的指向不可变&lt;br&gt;&amp;nbsp;&amp;nbsp;修饰方法:&amp;nbsp;方法不可被子类重写&lt;br&gt;&amp;nbsp;&amp;nbsp;修饰类:&amp;nbsp;类不可被继承&lt;br&gt;</p>
        
            <p class="question">18.yml&nbsp;Q:&amp;nbsp;说说反射的应用场景?&lt;br&gt;</p>
        
            <p class="answer">A:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;-&amp;nbsp;加载数据库驱动&lt;br&gt;&amp;nbsp;&amp;nbsp;-&amp;nbsp;解析注解&lt;br&gt;&amp;nbsp;&amp;nbsp;-&amp;nbsp;对象的反序列化&lt;br&gt;&amp;nbsp;&amp;nbsp;-&amp;nbsp;AOP的实现方案&lt;br&gt;</p>
        
            <p class="question">19.yml&nbsp;Q:&amp;nbsp;说说一个类的构造过程?&lt;br&gt;</p>
        
            <p class="answer">A:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;前提:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;子类中没有调用super的构造函数,系统会自动在第一行添加super()&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;构造函数中super(..)与this(..)不能共存,因为this(..)第一行为super,会重复构造父类&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;构造函数无法显式同时调用super(..)和this(..),因为都必须为第一行&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;隐式同时调用super(..)与this(..)不会重复构造父类,因为显式的this重定向后不会触发super&lt;br&gt;&amp;nbsp;&amp;nbsp;顺序:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;装载父类(按定义顺序调用static块、static属性)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;装载子类(按定义顺序调用static块、static属性)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;根据new&amp;nbsp;XXX(..)的参数调用构造方法&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;进入首行的super(..)直到Object&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;初始化类属性(按定义顺序调用init块、成员属性)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;执行构造方法的方法体(不执行this定向后的方法内的super)</p>
        
            <p class="question">20.yml&nbsp;Q:&amp;nbsp;Lambda与匿名内部类有什么区别?&lt;br&gt;</p>
        
            <p class="answer">A:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;-&amp;nbsp;Lambda的语法简洁&lt;br&gt;&amp;nbsp;&amp;nbsp;-&amp;nbsp;每个匿名内部类被编译成单独class文件,Lambda不会&lt;br&gt;&amp;nbsp;&amp;nbsp;-&amp;nbsp;Lambda只适用于单方法接口,&amp;nbsp;匿名内部类使用范围广:普通类,接口,抽象类</p>
        
            <p class="question">21.yml&nbsp;Q:&amp;nbsp;Object的hashCode是怎么生成的?&lt;br&gt;</p>
        
            <p class="answer">A:&lt;br&gt;&amp;nbsp;&amp;nbsp;总概:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;使用System.identityHashCode(obj)无视重写&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;可通过JVM运行参数修改hashCode的生成策略&lt;br&gt;&amp;nbsp;&amp;nbsp;要求:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;对象相同&amp;nbsp;=&gt;&amp;nbsp;hashCode相同&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;对象不同&amp;nbsp;=&gt;&amp;nbsp;hashCode未知(尽量不同)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;hashCode不同&amp;nbsp;=&gt;&amp;nbsp;对象未知&lt;br&gt;&amp;nbsp;&amp;nbsp;生成策略:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;对象的内存地址(默认)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;一种随机数&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;固定值&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;自增</p>
        
    </body>
    </html>
