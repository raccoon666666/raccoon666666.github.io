
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Document</title>
        <style>
        .question {
        border: 5px cornflowerblue solid;
        border-radius: 15px;
        padding: 10px;
        font-size: 24px;
        color: cornflowerblue;
        text-align: center;
    }</style>
        <style>
        .answer {
        width: fit-content;
        margin-left: auto;
        margin-right: auto;
        border: 1px orange solid;
        border-radius: 5px;
        padding: 20px;
        font-size: 20px;
        color: black;
    }</style>
    </head>
    <body>
        
            <p class="question">01.yml&nbsp;Q:&nbsp;线程的创建方式有哪些?<br></p>
        
            <p class="answer">A:&nbsp;<br>&nbsp;&nbsp;继承:<br>&nbsp;&nbsp;&nbsp;&nbsp;原理:&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;最本质的方法,继承Thread并重写run<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;new&nbsp;MyThread()<br>&nbsp;&nbsp;&nbsp;&nbsp;数据分离:&nbsp;公用数据定义为static&nbsp;;&nbsp;私用数据定义为成员<br>&nbsp;&nbsp;&nbsp;&nbsp;优劣:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;run中使用this即可获得当前线程<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;占用了父类<br>&nbsp;&nbsp;Runnable:<br>&nbsp;&nbsp;&nbsp;&nbsp;原理:&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;Thread可通过包装一个Runnable来实例化<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;new&nbsp;Thread(Runable)<br>&nbsp;&nbsp;&nbsp;&nbsp;数据分离:&nbsp;公用数据定义为成员<br>&nbsp;&nbsp;&nbsp;&nbsp;优劣:&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;可继承其他类<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;run中获取当前线程不方便&nbsp;;&nbsp;线程无法返回值<br>&nbsp;&nbsp;FutureTask:<br>&nbsp;&nbsp;&nbsp;&nbsp;原理:&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;FutureTask类已实现Runnable,只需出入一个Callable对象<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;new&nbsp;Thread(FutureTask(Callable))<br>&nbsp;&nbsp;&nbsp;&nbsp;数据分离:&nbsp;公用数据定义为成员<br>&nbsp;&nbsp;&nbsp;&nbsp;优劣:&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;可继承其他类&nbsp;;&nbsp;可获取线程返回值&nbsp;;&nbsp;可抛出异常<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;run中获取当前线程不方便&nbsp;;&nbsp;<br></p>
        
            <p class="question">02.yml&nbsp;Q:&nbsp;JMM是怎样的?<br></p>
        
            <p class="answer">A:&nbsp;<br>&nbsp;&nbsp;架构:&nbsp;每个线程对主内存的共享变量备份,各线程只能对备份操作<br>&nbsp;&nbsp;原子操作:&nbsp;#&nbsp;不会因时间片轮转而中断<br>&nbsp;&nbsp;&nbsp;&nbsp;read:&nbsp;读取主内存<br>&nbsp;&nbsp;&nbsp;&nbsp;load:&nbsp;将read的值写入线程内存<br>&nbsp;&nbsp;&nbsp;&nbsp;use:&nbsp;线程代码读取线程内存<br>&nbsp;&nbsp;&nbsp;&nbsp;assign:&nbsp;线程代码写入线程内存<br>&nbsp;&nbsp;&nbsp;&nbsp;store:&nbsp;读取线程内存<br>&nbsp;&nbsp;&nbsp;&nbsp;write:&nbsp;将store的值写回主内存<br>&nbsp;&nbsp;&nbsp;&nbsp;lock:&nbsp;将主内存的变量加锁<br>&nbsp;&nbsp;&nbsp;&nbsp;unlock:&nbsp;将主内存的变量解锁<br></p>
        
            <p class="question">03.yml&nbsp;Q:&nbsp;为什么volatile保证了哪些线程安全原则?没有保证哪些?为什么<br></p>
        
            <p class="answer">A:&nbsp;<br>&nbsp;&nbsp;可见性:&nbsp;#实现<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;线程内存变量更新后立即store,同时lock主内存变量(防止其他内存脏读),同时使其他线程内存变量失效<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;所有其他线程read,然而在等待锁<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;write成功,同时unlock<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;所有其他线程成功read,然后load回线程内存<br>&nbsp;&nbsp;有序性:&nbsp;#实现<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;编译器会对单线程中的汇编指令重排序<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;volatile变量的赋值前后有内存屏障,阻止指令重排<br>&nbsp;&nbsp;原子性:&nbsp;#未实现<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;底层的分为8大原子操作,可被时序重拍<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;一个线程store回主内存之前,其他线程已读取线程内存中的数据<br></p>
        
            <p class="question">04.yml&nbsp;Q:&nbsp;Java的线程运行在哪个态?<br></p>
        
            <p class="answer">A:&nbsp;<br>&nbsp;&nbsp;-&nbsp;操作系统的线程分为用户态ULT和内核态KLT<br>&nbsp;&nbsp;-&nbsp;ULT纯粹由某个线程模拟出来<br>&nbsp;&nbsp;-&nbsp;KLT由操作系统提供,是真实的线程<br>&nbsp;&nbsp;-&nbsp;通过观察操作系统中线程总数的变化可知,Java的线程是KLT</p>
        
            <p class="question">05.yml&nbsp;Q:&nbsp;Java并发中的synchronized关键字有哪些用法?原理是什么?<br></p>
        
            <p class="answer">A:&nbsp;<br>&nbsp;&nbsp;用法:<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;修饰static方法,使用Person.class对象作为锁<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;修饰成员方法,使用this对象作为锁<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;修饰局部块,使用自定义对象作为锁<br>&nbsp;&nbsp;原理:<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;Object-Monitor(等待队列)-Mutux<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;synchronized包裹的代码修饰成:monitorenter-xxx-monitorexit<br>&nbsp;&nbsp;锁类型:<br>&nbsp;&nbsp;&nbsp;&nbsp;可重入锁:&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;避免synchronized方法的递归带来的死锁<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;为避免异常而不能释放锁monitorexit&nbsp;>&nbsp;monitorenter<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;加锁>释放则死锁,加锁<释放则异常<br>&nbsp;&nbsp;&nbsp;&nbsp;互斥锁:&nbsp;读写都获取锁<br>&nbsp;&nbsp;&nbsp;&nbsp;非公平锁:&nbsp;先尝试获得锁,再进入等待队列<br>&nbsp;&nbsp;锁升级:&nbsp;&nbsp;&nbsp;#一旦升级不可逆<br>&nbsp;&nbsp;&nbsp;&nbsp;无锁:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;不抢锁时,只使用CAS完成数据修改<br>&nbsp;&nbsp;&nbsp;&nbsp;偏向锁:&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;第一次抢锁时,在Object标记该进程,并且不释放锁<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;第二次抢锁时,判断如果已被标记,直接获取已有的锁,无需抢锁<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;调用wait()时升级为重量级锁<br>&nbsp;&nbsp;&nbsp;&nbsp;轻量级锁:&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;如果偏向锁在被其他线程获取锁时有竞争,则升级为轻量级锁<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;使用CAS修改Object的锁标志位为自己,代替耗时的抢锁<br>&nbsp;&nbsp;&nbsp;&nbsp;重量级锁:&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;当自旋超过上下文切换的时间(自旋次数>10)后,升级为重量级锁<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;enter/exit需要JVM进入/退出内核态获取Mutex,效率低<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;没拿到锁的线程被阻塞,涉及到上下文切换和线程调度,效率低<br></p>
        
            <p class="question">06.yml&nbsp;Q:&nbsp;Java的CAS?<br></p>
        
            <p class="answer">A:&nbsp;<br>&nbsp;&nbsp;原理:&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;比较目标值是否等于期望值,是则修改成新值,返回是否成功<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;通过汇编lock和cmpexhg实现原子修改<br>&nbsp;&nbsp;优点:<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;可用空转模拟阻塞,避免线程状态切换<br>&nbsp;&nbsp;缺点:<br>&nbsp;&nbsp;&nbsp;&nbsp;单变量:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;只能解决对一个变量的原子操作<br>&nbsp;&nbsp;&nbsp;&nbsp;CPU开销:&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;若长时间空转,仍需阻塞<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;使用分段的LongAdder(单线程使用base,多线程使用cell,最终累加)<br>&nbsp;&nbsp;&nbsp;&nbsp;ABA问题:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;其他线程将value修改为ABA,所以CAS(A,C)能成功<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;但是数值上的A=A在业务逻辑上并不等价,所以CAS(A,C)不该执行<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;每次修改value就改变版本号,即可发现修改痕迹</p>
        
            <p class="question">07.yml&nbsp;Q:&nbsp;Lock和synchronize有什么区别<br></p>
        
            <p class="answer">A:&nbsp;<br>&nbsp;&nbsp;原理:<br>&nbsp;&nbsp;&nbsp;&nbsp;synchronized:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;-&nbsp;关键字,由JVM实现自动加锁与解锁<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;连续加多个锁时,自动以相反顺序释放锁<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;加锁与解锁限定在相同的作用域<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;无法知晓是否成功获取锁,获取锁的过程无法被打断<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;异常后自动释放锁<br>&nbsp;&nbsp;&nbsp;&nbsp;Lock:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;-&nbsp;API接口,手动控制加锁与解锁<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;自由控制解锁顺序,无需按照加锁的反顺序<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;加锁与解锁自由,可不在一个作用域<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;可通过API获取加锁成功性,且获取锁的过程可被打断<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;需要手动捕获异常并释放锁<br>&nbsp;&nbsp;实例对比:<br>&nbsp;&nbsp;&nbsp;&nbsp;synchronized:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;JVM使用Monitor实现了(非公平锁,互斥锁,可重入锁)<br>&nbsp;&nbsp;&nbsp;&nbsp;ReentrantLock:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;默认实现为(非公平锁,互斥锁,可重入锁),可显式设置为(公平锁,共享锁)</p>
        
            <p class="question">08.yml&nbsp;Q:&nbsp;多线程安全是什么?线程同步有哪些手段?<br></p>
        
            <p class="answer">A:&nbsp;<br>&nbsp;&nbsp;线程安全:&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;调用方无需显式同步,即可使任意时序的多线程都正确执行<br>&nbsp;&nbsp;三原则:<br>&nbsp;&nbsp;&nbsp;&nbsp;可见性:&nbsp;线程对共享变量的修改对于所有线程都可见<br>&nbsp;&nbsp;&nbsp;&nbsp;有序性:&nbsp;线程的代码不可被指令重拍<br>&nbsp;&nbsp;&nbsp;&nbsp;原子性:&nbsp;线程的代码对共享变量的操作是原子的<br>&nbsp;&nbsp;同步手段:&nbsp;&nbsp;&nbsp;#本质是控制线程的状态切换<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;Thread(join,sleep)<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;Object(wait,notify,notifyAll)<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;Condition(await,signal,signalAll)<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;LockSupport(park,unpark)&nbsp;+&nbsp;BlokingQueue<br>&nbsp;&nbsp;安全手段:<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;volatile<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;Lock&nbsp;,&nbsp;synchronized<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;BlockingQueue<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;AtomicInteger&nbsp;,&nbsp;LongAdder<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;ThreadLocal<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;不可变类型</p>
        
            <p class="question">09.yml&nbsp;Q:&nbsp;AQS是什么?如何实现的?<br></p>
        
            <p class="answer">A:&nbsp;<br>&nbsp;&nbsp;队列:&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;包含了管理调度线程执行的同步队列(双向链表)<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;包含了管理条件消息的条件队列(单向链表)<br>&nbsp;&nbsp;唤醒:<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;非传递唤醒则为独占模式,实现互斥锁<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;传递唤醒则为共享模式,实现共享锁<br></p>
        
            <p class="question">10.yml&nbsp;Q:&nbsp;BlockingQueue是如何设计的?有哪些方法?<br></p>
        
            <p class="answer">A:&nbsp;<br>&nbsp;&nbsp;方法:<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;针对不同的元素操作,在不同的场景提供不同的方法<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;抛异常&nbsp;&nbsp;特定值&nbsp;&nbsp;超时&nbsp;&nbsp;&nbsp;&nbsp;阻塞<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;增&nbsp;&nbsp;add&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;offer&nbsp;&nbsp;offer&nbsp;&nbsp;&nbsp;put<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;删&nbsp;&nbsp;remove&nbsp;&nbsp;poll&nbsp;&nbsp;&nbsp;pool&nbsp;&nbsp;&nbsp;&nbsp;take<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;查&nbsp;&nbsp;element&nbsp;peek<br>&nbsp;&nbsp;设计:<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;使用ReentrantLock作锁<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;使用两个Condition(notEmpty,notFull)作条件控制</p>
        
            <p class="question">11.yml&nbsp;Q:&nbsp;Object与Condition的条件控制有什么区别?<br></p>
        
            <p class="answer">A:&nbsp;<br>&nbsp;&nbsp;wait:&nbsp;前者使用Monitor对象,后者使用LockSupport.park()<br>&nbsp;&nbsp;notify:&nbsp;前者随机唤醒,后者唤醒队首<br>&nbsp;&nbsp;等待集:&nbsp;Object只有一个等待集,Lock可定义多个Condition实现多等待集<br></p>
        
            <p class="question">12.yml&nbsp;Q:&nbsp;ThreadLocal<br></p>
        
            <p class="answer">A:&nbsp;<br>&nbsp;&nbsp;原理:<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;Thread-ThreadLocalMap<ThreadLocal的自研hashcode,E><br>&nbsp;&nbsp;作用:<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;跨层传递数据<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;线程间数据隔离<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;事务操作<br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;数据库连接管理,Session会话管理</p>
        
    </body>
    </html>
