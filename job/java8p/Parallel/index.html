
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0, minimum-scale=1.0, user-scalable=no">
        <title>Document</title>
        <style>
        .question {
        border: 5px cornflowerblue solid;
        border-radius: 15px;
        padding: 10px;
        font-size: 24px;
        color: cornflowerblue;
        text-align: center;
    }</style>
        <style>
        .answer {
        width: fit-content;
        margin-left: auto;
        margin-right: auto;
        border: 1px orange solid;
        border-radius: 5px;
        padding: 20px;
        font-size: 20px;
        color: black;
    }</style>
    </head>
    <body>
        
            <p class="question">01.yml&nbsp;Q:&amp;nbsp;线程的创建方式有哪些?&lt;br&gt;</p>
        
            <p class="answer">A:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;继承:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;原理:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;最本质的方法,继承Thread并重写run&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;new&amp;nbsp;MyThread()&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;数据分离:&amp;nbsp;公用数据定义为static&amp;nbsp;;&amp;nbsp;私用数据定义为成员&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;优劣:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;run中使用this即可获得当前线程&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;占用了父类&lt;br&gt;&amp;nbsp;&amp;nbsp;Runnable:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;原理:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;Thread可通过包装一个Runnable来实例化&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;new&amp;nbsp;Thread(Runable)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;数据分离:&amp;nbsp;公用数据定义为成员&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;优劣:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;可继承其他类&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;run中获取当前线程不方便&amp;nbsp;;&amp;nbsp;线程无法返回值&lt;br&gt;&amp;nbsp;&amp;nbsp;FutureTask:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;原理:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;FutureTask类已实现Runnable,只需出入一个Callable对象&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;new&amp;nbsp;Thread(FutureTask(Callable))&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;数据分离:&amp;nbsp;公用数据定义为成员&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;优劣:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;可继承其他类&amp;nbsp;;&amp;nbsp;可获取线程返回值&amp;nbsp;;&amp;nbsp;可抛出异常&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;run中获取当前线程不方便&amp;nbsp;;&amp;nbsp;&lt;br&gt;</p>
        
            <p class="question">02.yml&nbsp;Q:&amp;nbsp;JMM是怎样的?&lt;br&gt;</p>
        
            <p class="answer">A:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;架构:&amp;nbsp;每个线程对主内存的共享变量备份,各线程只能对备份操作&lt;br&gt;&amp;nbsp;&amp;nbsp;原子操作:&amp;nbsp;#&amp;nbsp;不会因时间片轮转而中断&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;read:&amp;nbsp;读取主内存&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;load:&amp;nbsp;将read的值写入线程内存&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;use:&amp;nbsp;线程代码读取线程内存&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assign:&amp;nbsp;线程代码写入线程内存&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;store:&amp;nbsp;读取线程内存&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;write:&amp;nbsp;将store的值写回主内存&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;lock:&amp;nbsp;将主内存的变量加锁&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;unlock:&amp;nbsp;将主内存的变量解锁&lt;br&gt;</p>
        
            <p class="question">03.yml&nbsp;Q:&amp;nbsp;为什么volatile保证了哪些线程安全原则?没有保证哪些?为什么&lt;br&gt;</p>
        
            <p class="answer">A:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;可见性:&amp;nbsp;#实现&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;线程内存变量更新后立即store,同时lock主内存变量(防止其他内存脏读),同时使其他线程内存变量失效&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;所有其他线程read,然而在等待锁&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;write成功,同时unlock&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;所有其他线程成功read,然后load回线程内存&lt;br&gt;&amp;nbsp;&amp;nbsp;有序性:&amp;nbsp;#实现&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;编译器会对单线程中的汇编指令重排序&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;volatile变量的赋值前后有内存屏障,阻止其后指令置于其前,组织其前指令置于其后&lt;br&gt;&amp;nbsp;&amp;nbsp;原子性:&amp;nbsp;#未实现&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;底层的分为8大原子操作,可被时序重拍&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;一个线程store回主内存之前,其他线程已读取线程内存中的数据&lt;br&gt;</p>
        
            <p class="question">04.yml&nbsp;Q:&amp;nbsp;Java的线程运行在哪个态?&lt;br&gt;</p>
        
            <p class="answer">A:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;-&amp;nbsp;操作系统的线程分为用户态ULT和内核态KLT&lt;br&gt;&amp;nbsp;&amp;nbsp;-&amp;nbsp;ULT纯粹由某个线程模拟出来&lt;br&gt;&amp;nbsp;&amp;nbsp;-&amp;nbsp;KLT由操作系统提供,是真实的线程&lt;br&gt;&amp;nbsp;&amp;nbsp;-&amp;nbsp;通过观察操作系统中线程总数的变化可知,Java的线程是KLT</p>
        
            <p class="question">05.yml&nbsp;Q:&amp;nbsp;synchronized有哪些用法?原理是什么?&lt;br&gt;</p>
        
            <p class="answer">A:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;用法:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;修饰static方法,使用Person.class对象作为锁&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;修饰成员方法,使用this对象作为锁&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;修饰局部块,使用自定义对象作为锁&lt;br&gt;&amp;nbsp;&amp;nbsp;原理:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;Object-Monitor(等待队列)-Mutux&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;synchronized包裹的代码修饰成:monitorenter-xxx-monitorexit&lt;br&gt;&amp;nbsp;&amp;nbsp;锁类型:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;可重入锁:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;避免synchronized方法的递归带来的死锁&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;为避免异常而不能释放锁monitorexit&amp;nbsp;&gt;&amp;nbsp;monitorenter&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;加锁&gt;释放则死锁,加锁&lt;释放则异常&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;互斥锁:&amp;nbsp;读写都获取锁&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;非公平锁:&amp;nbsp;先尝试获得锁,再进入等待队列&lt;br&gt;&amp;nbsp;&amp;nbsp;锁升级:&amp;nbsp;&amp;nbsp;&amp;nbsp;#一旦升级不可逆&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;无锁:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;不抢锁时,只使用CAS完成数据修改&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;偏向锁:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;第一次抢锁时,在Object标记该进程,并且不释放锁&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;第二次抢锁时,判断如果已被标记,直接获取已有的锁,无需抢锁&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;调用wait()时升级为重量级锁&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;轻量级锁:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;如果偏向锁在被其他线程获取锁时有竞争,则升级为轻量级锁&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;使用CAS修改Object的锁标志位为自己,代替耗时的抢锁&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;重量级锁:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;当自旋超过上下文切换的时间(自旋次数&gt;10)后,升级为重量级锁&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;enter/exit需要JVM进入/退出内核态获取Mutex,效率低&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;没拿到锁的线程被阻塞,涉及到上下文切换和线程调度,效率低&lt;br&gt;</p>
        
            <p class="question">06.yml&nbsp;Q:&amp;nbsp;Java的CAS?&lt;br&gt;</p>
        
            <p class="answer">A:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;原理:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;比较目标值是否等于期望值,是则修改成新值,返回是否成功&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;通过汇编lock和cmpexhg实现原子修改&lt;br&gt;&amp;nbsp;&amp;nbsp;优点:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;可用空转模拟阻塞,避免线程状态切换&lt;br&gt;&amp;nbsp;&amp;nbsp;缺点:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;单变量:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;只能解决对一个变量的原子操作&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;CPU开销:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;若长时间空转,仍需阻塞&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;使用分段的LongAdder(单线程使用base,多线程使用cell,最终累加)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ABA问题:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;其他线程将value修改为ABA,所以CAS(A,C)能成功&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;但是数值上的A=A在业务逻辑上并不等价,所以CAS(A,C)不该执行&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;每次修改value就改变版本号,即可发现修改痕迹</p>
        
            <p class="question">07.yml&nbsp;Q:&amp;nbsp;Lock和synchronize有什么区别&lt;br&gt;</p>
        
            <p class="answer">A:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;原理:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;synchronized:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;-&amp;nbsp;关键字,由JVM实现自动加锁与解锁&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;连续加多个锁时,自动以相反顺序释放锁&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;加锁与解锁限定在相同的作用域&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;无法知晓是否成功获取锁,获取锁的过程无法被打断&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;异常后自动释放锁&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Lock:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;-&amp;nbsp;API接口,手动控制加锁与解锁&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;自由控制解锁顺序,无需按照加锁的反顺序&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;加锁与解锁自由,可不在一个作用域&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;可通过API获取加锁成功性,且获取锁的过程可被打断&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;需要手动捕获异常并释放锁&lt;br&gt;&amp;nbsp;&amp;nbsp;实例对比:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;synchronized:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;JVM使用Monitor实现了(非公平锁,互斥锁,可重入锁)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ReentrantLock:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;默认实现为(非公平锁,互斥锁,可重入锁),可显式设置为(公平锁,共享锁)</p>
        
            <p class="question">08.yml&nbsp;Q:&amp;nbsp;多线程安全是什么?线程同步有哪些手段?&lt;br&gt;</p>
        
            <p class="answer">A:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;线程安全:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;调用方无需显式同步,即可使任意时序的多线程都正确执行&lt;br&gt;&amp;nbsp;&amp;nbsp;三原则:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;可见性:&amp;nbsp;线程对共享变量的修改对于所有线程都可见&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;有序性:&amp;nbsp;线程的代码不可被指令重拍&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;原子性:&amp;nbsp;线程的代码对共享变量的操作是原子的&lt;br&gt;&amp;nbsp;&amp;nbsp;同步手段:&amp;nbsp;&amp;nbsp;&amp;nbsp;#本质是控制线程的状态切换&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;Thread(join,sleep)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;Object(wait,notify,notifyAll)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;Condition(await,signal,signalAll)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;LockSupport(park,unpark)&amp;nbsp;+&amp;nbsp;BlokingQueue&lt;br&gt;&amp;nbsp;&amp;nbsp;安全手段:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;volatile&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;Lock&amp;nbsp;,&amp;nbsp;synchronized&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;BlockingQueue&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;AtomicInteger&amp;nbsp;,&amp;nbsp;LongAdder&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;ThreadLocal&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;不可变类型</p>
        
            <p class="question">09.yml&nbsp;Q:&amp;nbsp;AQS是什么?如何实现的?&lt;br&gt;</p>
        
            <p class="answer">A:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;作用:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;为实现锁或其他同步组件提供通用方法&lt;br&gt;&amp;nbsp;&amp;nbsp;实现的功能:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;同步状态控制量:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;对于Lock,表示线程重入次数&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;对于Semaphore,表示剩余资源数&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;对于FutureTask,表示任务的状态(未开始、运行中、完成、取消)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;对于CountDownLatch,表示&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;等待队列:&amp;nbsp;管理线程调度的队列(双向链表)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;条件队列:&amp;nbsp;管理条件消息的队列(单向链表)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;线程唤醒:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;非传递唤醒则为独占模式,实现互斥锁&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;传递唤醒则为共享模式,实现共享锁&lt;br&gt;</p>
        
            <p class="question">10.yml&nbsp;Q:&amp;nbsp;BlockingQueue是如何设计的?有哪些方法?&lt;br&gt;</p>
        
            <p class="answer">A:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;方法:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;针对不同的元素操作,在不同的场景提供不同的方法&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;抛异常&amp;nbsp;&amp;nbsp;特定值&amp;nbsp;&amp;nbsp;超时&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;阻塞&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;增&amp;nbsp;&amp;nbsp;add&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;offer&amp;nbsp;&amp;nbsp;offer&amp;nbsp;&amp;nbsp;&amp;nbsp;put&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;删&amp;nbsp;&amp;nbsp;remove&amp;nbsp;&amp;nbsp;poll&amp;nbsp;&amp;nbsp;&amp;nbsp;pool&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;take&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;查&amp;nbsp;&amp;nbsp;element&amp;nbsp;peek&lt;br&gt;&amp;nbsp;&amp;nbsp;设计:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;使用ReentrantLock作锁&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;使用两个Condition(notEmpty,notFull)作条件控制</p>
        
            <p class="question">11.yml&nbsp;Q:&amp;nbsp;Object与Condition的条件控制有什么区别?&lt;br&gt;</p>
        
            <p class="answer">A:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;wait:&amp;nbsp;前者使用Monitor对象,后者使用LockSupport.park()&lt;br&gt;&amp;nbsp;&amp;nbsp;notify:&amp;nbsp;前者随机唤醒,后者唤醒队首&lt;br&gt;&amp;nbsp;&amp;nbsp;等待集:&amp;nbsp;Object只有一个等待集,Lock可定义多个Condition实现多等待集&lt;br&gt;</p>
        
            <p class="question">12.yml&nbsp;Q:&amp;nbsp;ThreadLocal&lt;br&gt;</p>
        
            <p class="answer">A:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;功能:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;针对某个固定的ThreadLocal对象(public&amp;nbsp;static&amp;nbsp;ThreadLocal&amp;nbsp;session)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;相同的调用代码,根据当前线程的不同,从该ThreadLocal中拿出的值也不同&lt;br&gt;&amp;nbsp;&amp;nbsp;原理:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;ThreadLocal本身不存VALUE,只是一个标记&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;Thread对象&amp;nbsp;==&amp;nbsp;1个ThreadLocalMap&lt;ThreadLocal,E&gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;ThreadLocal的值保存在Thread中,针对每个ThreadLocal保存一个值&lt;br&gt;&amp;nbsp;&amp;nbsp;Hash冲突:&amp;nbsp;TheadLocal定义静态原子base,每次实例化计算base+Delta作为其HASH值&lt;br&gt;&amp;nbsp;&amp;nbsp;若引用:&amp;nbsp;ThreadLocalMap数组中保存的Entry是弱引用,因为要避免ThreadLocal对象无法回收&lt;br&gt;&amp;nbsp;&amp;nbsp;应用场景:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;跨层传递数据&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;线程间数据隔离&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;事务操作&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;数据库Connection管理&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;Session会话管理</p>
        
            <p class="question">13.yml&nbsp;Q:&amp;nbsp;说说你对读写锁的理解?&lt;br&gt;</p>
        
            <p class="answer">A:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;-&amp;nbsp;与互斥锁的只要有线程读写就加锁不同,线程可同时读&lt;br&gt;&amp;nbsp;&amp;nbsp;-&amp;nbsp;当读&gt;&gt;写时由于读读不阻塞,效率比互斥锁高&lt;br&gt;&amp;nbsp;&amp;nbsp;-&amp;nbsp;当并发不是很高时,由于需要维护读锁状态,效率比互斥锁低&lt;br&gt;&amp;nbsp;&amp;nbsp;-&amp;nbsp;降级:写线程可通过获取读锁,在自己释放写锁后,与其他读线程共享读</p>
        
            <p class="question">14.yml&nbsp;Q:&amp;nbsp;JUC包括哪些功能?&lt;br&gt;</p>
        
            <p class="answer">A:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;线程池:&amp;nbsp;Executor、ThreadPoolExecutor&lt;br&gt;&amp;nbsp;&amp;nbsp;原子更新:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;使用CAS在多线程下实现原子操作&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;原子基本类型、原子数组、原子引用、原子字段&lt;br&gt;&amp;nbsp;&amp;nbsp;锁和条件:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;用于阻塞的锁和用于唤醒的条件&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;Lock、Condition&lt;br&gt;&amp;nbsp;&amp;nbsp;阻塞队列:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;用于生产者-消费者模型&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;BlockingQueue&lt;br&gt;&amp;nbsp;&amp;nbsp;并发容器:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;实现了线程安全的集合类&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;Concurrent、CopyOnWrite&lt;br&gt;&amp;nbsp;&amp;nbsp;同步器:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;协助同步&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;Semaphore、FutureTask</p>
        
            <p class="question">15.yml&nbsp;Q:&amp;nbsp;说说你对线程池的理解?&lt;br&gt;</p>
        
            <p class="answer">A:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;-&amp;nbsp;Java的线程是KLT,启动一个线程的成本高&lt;br&gt;&amp;nbsp;&amp;nbsp;-&amp;nbsp;线程池在系统启动时创建一定数量线程,通过对线程复用,适合运行大量生存期短的线程&lt;br&gt;&amp;nbsp;&amp;nbsp;-&amp;nbsp;只需将Runnable和Callable传入线程池,其自动分配线程去执行它&lt;br&gt;</p>
        
            <p class="question">16.yml&nbsp;Q:&amp;nbsp;说说CountDownLatch的原理与作用?&lt;br&gt;</p>
        
            <p class="answer">A:&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;原理:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;new&amp;nbsp;CountDownLatch(线程数),表示要等待的线程数量&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;等待方线程调用obj.await()等待其他线程完成&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;被等待方线程执行完毕后调用obj.countDown()&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;减少到0时,await被唤醒&lt;br&gt;&amp;nbsp;&amp;nbsp;作用:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;类似于thread.join()&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;nbsp;用于任务的并行拆分</p>
        
    </body>
    </html>
